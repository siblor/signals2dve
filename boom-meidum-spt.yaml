# Signal configuration list for DVE
#
#
# - To reference iterators and expresions, use always the capsule ${ }.
# - Always check the DVE's console after loading the script. Some signals could be not found
# 
# Examples are shown below for a BOOM Medium configuration

env:
  top: TestDriver.testHarness.chiptop.system.tile_prci_domain.tile_reset_domain.boom_tile
  core: $top.core
  width: 2

settings:
  line_limit: 3900
  allowed_radices: ['decimal' , 'binary', 'hex', 'oct', 'ascii']
  wave_name: 'Wave.1'
  starting_id: 1        # Pick a higher number if there are already groups created ()
  collapse_all: true    # Collapse all groups

defaults:
  # for radix, dve default is already hex
  collapse: true
  divider_name: 'Divider'

  uop_base: &uop_base  
    # Core Operation Fields  
    - path: '_uopc'               # Micro-operation code specifying the operation type  
      radix: decimal  
    - path: '_inst'               # 32-bit RISC-V instruction word  
    - path: '_debug_inst'         # Debug version of instruction  
    - path: '_is_rvc'             # True if 16-bit compressed RISC-V instruction  
    - path: '_debug_pc'           # Debug program counter value  
    - path: '_iq_type'            # Issue queue type (integer, memory, or floating-point)  
    - path: '_fu_code'            # Functional unit code specifying execution unit  
      radix: decimal  
  
  uop_ctrl_flow: &uop_ctrl_flow
    # Branch and Control Flow Fields  
    - path: '_is_br'              # True if this is a branch instruction  
    - path: '_is_jalr'            # True if this is a JALR (jump and link register) instruction  
    - path: '_is_jal'             # True if this is a JAL (jump and link) instruction  
    - path: '_is_sfb'             # Shadow fetch branch or in shadow of one for branch prediction optimization  
    - path: '_br_mask'            # Branch mask indicating which speculative branches this depends on  
    - path: '_br_tag'             # Branch tag for tracking speculative execution  
    - path: '_ftq_idx'            # Index into Fetch Target Queue for fetch PC and prediction metadata  
    - path: '_edge_inst'          # True if instruction straddles two fetch packets (crosses fetch boundary)  
    - path: '_pc_lob'             # Low-order bits of PC, combined with FTQ entry to get full PC  
    - path: '_taken'              # True if this branch was predicted taken 
    # Debug and Tracing Fields  
    - path: '_debug_fsrc'         # Source tracking for branch prediction  
  
  uop_regs: &uop_regs
    # Logical Register Fields  
    - path: '_ldst'               # Logical destination register specifier  
      radix: decimal  
    - path: '_lrs1'               # Logical source register 1 specifier  
      radix: decimal  
    - path: '_lrs2'               # Logical source register 2 specifier  
      radix: decimal  
    - path: '_lrs3'               # Logical source register 3 specifier (for FP operations)  
      radix: decimal  
    - path: '_ldst_val'           # True if there is a valid destination register  
    - path: '_dst_rtype'          # Destination register type (integer, FP, etc.)  
    - path: '_lrs1_rtype'         # Source register 1 type  
    - path: '_lrs2_rtype'         # Source register 2 type  
    - path: '_frs3_en'            # True if floating-point source register 3 is enabled  
    # Register and Data Fields  
    - path: '_imm_packed'         # Densely packed immediate value for decode stage  
    - path: '_pdst'               # Physical destination register number  
      radix: decimal  
    - path: '_prs1'               # Physical source register 1 number  
      radix: decimal  
    - path: '_prs2'               # Physical source register 2 number  
      radix: decimal  
    - path: '_prs1_busy'          # True if physical source register 1 is busy/not ready  
    - path: '_prs2_busy'          # True if physical source register 2 is busy/not ready  
    - path: '_stale_pdst'         # Previous physical destination register for freelist management  
  
  uop_xcp: &uop_xcp
    # Exception and Control Fields  
    - path: '_exception'          # True if this instruction has an exception  
    - path: '_exc_cause'          # Exception cause code  
    - path: '_bypassable'         # True if ALU results can be bypassed (fixed latency operations)
    - path: '_xcpt_pf_if'         # True if instruction fetch page fault exception occurred  
    - path: '_xcpt_ae_if'         # True if instruction fetch access exception occurred  
    - path: '_bp_debug_if'        # True if breakpoint debug exception during instruction fetch  
    - path: '_bp_xcpt_if'         # True if breakpoint exception during instruction fetch  
  
  uop_mem: &uop_mem
    # Memory Operation Fields  
    - path: '_mem_cmd'            # Memory command type for loads/stores  
    - path: '_mem_size'           # Memory operation size  
    - path: '_mem_signed'         # True if memory operation is signed  
    - path: '_is_fence'           # True if this is a memory fence instruction  
    - path: '_is_fencei'          # True if this is an instruction fence  
    - path: '_is_amo'             # True if this is an atomic memory operation  
    - path: '_uses_ldq'           # True if instruction uses the load queue  
    - path: '_uses_stq'           # True if instruction uses the store queue  
    - path: '_is_sys_pc2epc'      # True for system calls (ECALL) and breakpoints that set EPC to PC  
    - path: '_is_unique'          # True if instruction must execute alone in pipeline (serializing)  
    - path: '_flush_on_commit'    # True if instruction needs to flush pipeline behind it on commit  
  

  uop_fp: &uop_fp
    # Floating-Point Fields  
    - path: '_fp_val'             # True if this is a floating-point instruction  
    - path: '_fp_single'          # True if single-precision floating-point instruction  

  uop_full: &uop_full
    - children: *uop_base
    - children: *uop_ctrl_flow
    - children: *uop_regs
    - children: *uop_xcp
    - children: *uop_mem
    - children: *uop_fp


# Groups
groups:
    # General control signals 
  - name: 'Control'                     # Name that will show on DVE GUI
    base: $core                         # Full signal path before the signal name at this level (no trailing . or _)
    collapse: false                     # Collapse the group after loading the script
    children:                           # Signals and dividers in this group (not sub groups!)
      - path: .clock                    # Name of this signal
      - path: .reset
      - path: .csr_io_interrupt
      - path: .csr_io_interrupt_cause

    # Decode stage
  - name: 'Decode'                      
    base: $core                         
    collapse: true
    children: []                        # [] for empty in this level
    subgroups:                          # Subgroups are defined here
      - name: 'Decode Unit ${w}'          # Name of the group. It can use $vars form env, $iterators and $expresions
        base: '.decode_units_${w}'
        iterators: {w: $width}                 # How many copies of this (sub)group will be created
        children:
          - base: '.io_enq_uop'
            children: *uop_full           # list of signals can be reused and added as a group with the keyword 'children' to avoid repetition
  
  # Rename stage
  - name: 'Rename'
    base: '$core'
    children: []
    subgroups:
      - name: 'Integer Rename'
        base: '.rename_stage'
        children: []
        subgroups:
          - name: 'i ren $w'
            base: ''
            iterators: {w: $width}
            children:
              - path: '.io_ren2_mask_$w'
              - path: '.io_ren_stalls_$w'
              - base: '.io_ren2_uops_$w' 
                children: *uop_full
      - name: 'FP Rename'
        base: '.fp_rename_stage'
        children: []
        subgroups:
          - name: 'fp ren $w'
            base: ''
            iterators: {w: $width}
            children:
              - path: '.io_ren_stalls_$w'
              - base: '.io_ren2_uops_$w' 
                children: *uop_full
                
  # Dispatch stage
  - name: 'Dispatcher'
    base: '$core'
    children: []
    subgroups:
      - name: 'dis $w'
        base: ''
        iterators: {w: $width, i: 1}          # For some reason there are 3 identical instances or io_dis_uops. Only using 0 ($i)
        children:
          - path: '.dis_valids_$w'
          - path: '.dis_fire_$w'
          - path: '.dis_hazards_$w'
          - path: '.dispatcher.io_dis_uops_$i_$w_ready'
          - path: '.dispatcher.io_dis_uops_$i_$w_valid'
          - base: '.dispatcher.io_dis_uops_$i_$w_bits' 
            children: *uop_full

  # ReOrder Buffer
  - name: 'ROB'
    base: '$core.rob'
    children:
      - path: '.rob_head_idx'
        radix: decimal                  # Change radix of the signal
      - path: '.rob_pnr_idx'
        radix: decimal
      - path: '.rob_tail_idx'
        radix: decimal
      - path: 'full'
      - path: 'empty'
    subgroups:
      - name: 'Entries'
        base: ''
        subgroups:  
          - name: 'idx ${idx}'
            base: ''
            iterators:
              e: 32       # entries of ROB
              b: 2        # banks of ROB
            expr:                       # Expresions can be constructed with iterators for custom naming
              idx: '(e << 1) + b'                 # entry number since they are alternated between banks
              bd: ' "1" if b == 1 else "" '       # Bank display (since it is '' if b=0) 
            children:
              - path: '.rob_val_${bd}_${e}'
              - path: '.rob_bsy_${bd}_${e}'
              - path: '.rob_unsafe_${bd}_${e}'
              - path: '.rob_exception_${bd}_${e}'
              - path: '.rob_predicated_${bd}_${e}'
              - base: '.rob_uop_${bd}_${e}'
                children: *uop_full
      - name: 'Commit lane $w'
        base: '.io_commit'
        iterators: { w: $width }
        children:
          - path: '_valids_$w'
          - base: '_uops_$w'
            children: *uop_full
      - name: 'Enqueue lane $w'
        base: '.io_commit'
        iterators: { w: $width }
        children:
          - path: '_valids_$w'
          - base: '_uops_$w'
            children: *uop_full

  # Issue stage
  - name: 'Issue Units'
    base: '$core'
    children: []
    subgroups:
      - name: 'Untaint bus'
        base: '.global_untaint_broadcast'
        children:
          - path: '0_valid'
          - path: '0_bits_preg'
          - path: '0_bits_is_fp'
          - path: '1_valid'
          - path: '1_bits_preg'
          - path: '1_bits_is_fp'
          - divider: 'Memory IU'
          - path: '2_valid'
          - path: '2_bits_preg'
          - path: '2_bits_is_fp'
          - divider: 'FP IU'
          - path: '3_valid'
          - path: '3_bits_preg'
          - path: '3_bits_is_fp'

      - name: 'Integer IU'
        base: '.int_issue_unit'
        subgroups:
          - name: 'Issue lane $w'
            base: '.io_iss'
            iterators: {w: 2}
            children:
              - path: _valids_$w
              - base: _uops_$w
                children: *uop_full
          - name: 'Slots'
            subgroups:
              - name: 'Slot $s'
                base: '.slots_$s'
                iterators: {s: 20}
                children: *slot_children
                subgroups: *slot_subgroups
    
      # - name: 'Memory IU'
      #   base: '.mem_issue_unit'
      #   children:
      #     - 
      #   subgroups:
      #     - name: 'Slot $s'
      #       base: '.slots_$s'
      #       iterators: {s: 12}
      #       children:
      #         - path:

      # - name: 'FP IU'
      #   base: '.fp_pipeline.fp_issue_unit'
      #   children:
          
      #   subgroups:
      #     - name: 'Slot $s'
      #       base: '.slots_$s'
      #       iterators: {s: 12}
      #       children:
      #       - path:  
